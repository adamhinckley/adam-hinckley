---
title: "When to use Zustand over Context and avoid a common footgun that kills performance"
date: "2026-02-09"
summary: |
  Zustand is a lightweight powerhouse for global state in React, but a tiny misuse—like destructuring the store incorrectly—can trigger unnecessary re-renders and kill performance. Learn when to stick with Context, when to upgrade to Zustand, and how to use it without shooting yourself in the foot.
coverImage: "/articles/hello-contentlayer.svg"
---

import ContextDemo from "../components/ContextDemo";
import ZustandDemo from "../components/ZustandShallowDemo";

## Using Zustand to boost performance in React apps? It works, but watch out for this common footgun.

<a href="#live-demo" className="cursor:pointer text-sm text-zinc-500 dark:text-zinc-400 mb-4">
  There are live components below to try it out.
</a>

Global state lives wherever multiple components need to read or update the same data: user session,
cart contents, UI toggles, filters, or form progress.

The right tool depends on **scale**, **update frequency**, and **how performance-sensitive your UI
is**. Here's a practical guide with copy-paste examples.

## When Context is enough

Use React Context when the state:

- changes infrequently (theme, locale, auth session)
- is read by many components but updated in a few places
- does not need advanced debugging or middleware

Context keeps your dependency graph simple and ships with React. The tradeoff is that every change
re-renders all consumers, which can become costly for fast, frequent updates.

## When Context is enough (and preferable)

Stick with React's built-in **Context API** when your global state:

- Changes **infrequently** (theme toggles, user auth token, app locale, feature flags)
- Is **read-heavy** but updated in only a few controlled places
- Doesn't require advanced debugging, middleware, or persistence out of the box

Context is zero-dependency, ships with React, and avoids adding another library. Example of a
well-optimized theme context:

```tsx
import { createContext, useContext, useMemo, useState } from "react";

type Theme = "light" | "dark";
type ThemeContextValue = {
  theme: Theme;
  setTheme: (theme: Theme) => void;
};

const ThemeContext = createContext<ThemeContextValue | null>(null);

export function ThemeProvider({ children }: { children: React.ReactNode }) {
  const [theme, setTheme] = useState<Theme>("light");
  const value = useMemo(() => ({ theme, setTheme }), [theme]);

  return <ThemeContext.Provider value={value}>{children}</ThemeContext.Provider>;
}

export function useTheme() {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error("useTheme must be used inside ThemeProvider");
  }

  return context;
}
```

```tsc
// In a component
const { theme, setTheme } = useTheme();
```

This pattern works great until state updates become more frequent or affect more components.

## When Zustand is a good fit

When Context starts feeling inadequate — time to consider Zustand

As your product app grows—think interactive dashboards, real-time filters, shopping carts,
multi-step forms, or collaborative UI—Context often reveals its main limitation:

- **Broad re-renders**: Any value change in the context object triggers re-renders in all consumers
  (and their subtrees) unless you memoize everything aggressively.
- **Provider hell**: Multiple independent pieces of state force nested providers or a giant merged
  context, cluttering JSX and complicating composition.
- **No built-in selectivity**: You end up manually optimizing with `useMemo`, custom hooks, or
  splitting contexts—adding boilerplate and maintenance cost.

Zustand shines exactly here: it's a tiny 95 kB, hook-first store that gives you selective
subscriptions out of the box. Only components that depend on changed state re-render—no aggressive
memoization required.

## Quick migration path from Context → Zustand

Zustand's API feels familiar:

```tsx
import { create } from "zustand";

type ThemeState = {
  theme: "light" | "dark";
  setTheme: (theme: "light" | "dark") => void;
};

export const useThemeStore = create<ThemeState>((set) => ({
  theme: "light",
  setTheme: (theme) => set({ theme }),
}));
```

```tsx
// In a component — selective & performant
const theme = useThemeStore((state) => state.theme);
const setTheme = useThemeStore((state) => state.setTheme);
```

Or combine them (common pattern):

```tsx
const { theme, setTheme } = useThemeStore((state) => ({
  theme: state.theme,
  setTheme: state.setTheme,
}));
```

**But here's the footgun** → the last example can cause unnecessary re-renders if you don't handle
it correctly.

## The common footgun: Destructuring values from the store can kill performance gains you were expecting

Many developers (myself included at first) write this:

```tsx
// ❌ Dangerous: causes re-renders on unrelated state changes
const { theme, setTheme } = useThemeStore();
```

Or even:

```tsx
// ❌ Creates a new object reference every render → Zustand sees "change"
const { theme, setTheme } = useThemeStore((state) => ({
  theme: state.theme,
  setTheme: state.setTheme,
}));
```

**Why this hurts performance** Zustand uses strict equality (Object.is) to decide whether to notify
subscribers. When your selector returns a fresh object `{ ...}` every time the component renders
(even if the inner values are unchanged), Zustand thinks the selected state changed → your component
re-renders unnecessarily.

Worse: if any unrelated slice of state updates (e.g., a counter elsewhere in the same store), the
whole component re-renders because the returned object is always new.

## How to fix it — best practices for selectors

1. Prefer single-value (atomic) selectors — safest and most performant

```tsx
const theme = useThemeStore((state) => state.theme);
const setTheme = useThemeStore((state) => state.setTheme);
```

2. When you need multiple values: use `useShallow` equality

```tsx
import { useShallow } from "zustand/react/shallow";

const { theme, setTheme } = useThemeStore(
  useShallow((state) => ({ theme: state.theme, setTheme: state.setTheme })),
);
```

<div id="live-demo" />
<ContextDemo />
